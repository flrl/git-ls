#!/usr/bin/env perl
# list files and their git properties

use warnings;
use strict;
use 5.012;

sub ansic
{
    return "\033["
           . join(';', map { int $_ } @_)
           . 'm';
}

sub commit_colour
{
    my ($sha1) = @_;
    my $c0 = substr($sha1, 0, 1) eq '^' ? 1 : 0;

    no warnings 'portable'; # quiet 64 bit ints please
    return (38, 5, 17 + hex(substr($sha1, $c0, 16)) % 214);
}

sub find_files
{
    my @files;

    foreach my $path (@_) {
        if (-d $path) {
            opendir(my $dh, $path) || die "openddir $path: $!";
            while (readdir $dh) {
                next if $_ eq q{.} or $_ eq q{..};
                next if $_ eq q{.git};
                push @files, $path eq q{.} ? $_ : "$path/$_";
            }
            closedir $dh;
        }
        else {
            push @files, $path;
        }
    }

    return @files;
}

sub list_file
{
    my ($path) = @_;

    my @git_log = qx{git rev-list -n 1 --pretty=tformat:%H%x09%an%x09%ci --no-commit-header HEAD -- $path};
    my $commit = shift @git_log;
    die "git log returned multiple lines" if scalar @git_log;

    if ($commit) {
        chomp $commit;
        my ($sha1, $author_name, $commit_date) = split /\t/, $commit;

        print ansic(commit_colour($sha1));
        printf '%-12.12s %-19.19s %s ', $sha1, $author_name, $commit_date;
        print ansic(0);
        print $path, "\n";
    }
    else {
        print ansic(31);
        printf '%-59s', 'not committed';
        print ansic(0);
        print $path, "\n";
    }
}

my @files = find_files('.');
list_file($_) for @files;
